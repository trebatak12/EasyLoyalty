# EasyLoyalty – MUST #1: Double‑Entry Ledger (Final Replit Agent Prompt v2)

> **Goal for agent:** Implement the **Double‑Entry Ledger** end‑to‑end exactly as specified **below**. Work **only** inside the ledger scope. **Do not modify** auth or other modules. Implement in **phases A→B→C→D→E** and **pause after each checkpoint** (wait for my "continue"). Contracts are the single **source of truth**; if something must change, **STOP** and comment why.

---

## 0) Project guardrails (do not break)

### 0.1 Repo‑specific bindings (this project)

* **Admin auth:** Pro /dev/\* a /trial-balance použij stávající **AdminAuthProvider** (nepřidávej nový middleware). Non‑admin → 403.

* **Legacy tabulky:** Existuje vaše `transactions` (pro wallet operace). **NESAHEJ** na ni; nová účetní vrstva běží v **`ledger_transactions`/`ledger_entries`**. Případné mapování na legacy řeš pouze přes `origin_ref` (string) nebo migrační backfill (viz Appendix A).

* **Wallet vs. balances:** `wallets.balance_cents` ber jako **projekci** (read‑model). Zdroj pravdy je **ledger** + `account_balances`. V přechodné fázi používej **dual‑write** z ledgeru do `wallets.balance_cents` (viz Appendix A), nebo z `wallets.balance_cents` udělej view, pokud to stav dovolí.

* **Contracts umístění:** Místo `/contracts/ledger.ts` používej **`/shared/contracts/ledger.ts`** a z něj importuj FE i BE typy.

* **Konflikt názvů:** `transactions` (legacy) a `ledger_transactions` (nové) se **nejmenují stejně** ⇒ kolize názvů v DB není.

* **Scope lock:** Only implement the ledger (DB schema, backend logic, dev‑only API, tiny dev FE page, metrics, validator). **Do not** touch legacy endpoints, existing auth, or unrelated modules.

* **Routing:** All new endpoints live under **`/api/v1/ledger/*`** (no `/v2`).

* **Shared contracts:** FE **and** BE import shared Zod/TS contracts from **`/shared/contracts/ledger.ts`**. These contracts **must not change** without explicit STOP & comment.

* **Feature flags:**

  * `LEDGER_ENABLED` (bool) — default **OFF**; enables the dev FE page and FE wiring when true.
  * `LEDGER_DEV_ENDPOINTS_ENABLED` (bool) — default **true** in dev/stage, **false** in prod; controls `/dev/*` routes. Prod = they must return **403**.

* **Production definition:** Treat **prod** as `LEDGER_DEV_ENDPOINTS_ENABLED=false`. `NODE_ENV=production` can also be true, but the guard **must** follow the flag above.

* **Error envelope:** All errors return JSON `{ error: CODE, message: string, details?: any }` with the codes listed below.

* **Time & locale:** All server timestamps and `trial_balance` logic use **UTC**. `as_of_date` is an **UTC date**.

* **No external calls inside DB tx:** Write entries & balances in **one DB transaction**; emit telemetry/notifications **after commit**.

---

## 1) Scope & objectives

* Provide **double‑entry accounting** for customer credits:

  * Every transaction must satisfy **Σdebit = Σcredit**.
  * Nothing is overwritten; mistakes are fixed via a **reversal transaction**.
* Deliverables:

  * **DB schema** (Drizzle/Postgres) + indexes/constraints.
  * **Backend logic** implementing operations & invariants.
  * **Dev‑only API** for manual tests.
  * **Basic metrics** & **daily trial‑balance** check (Σdebit − Σcredit = 0).
  * **FE wiring (dev‑only page)** using the shared contracts.
  * **Validator script** `npm run validate:must1` (E2E smoke) + CI job.
* **Out‑of‑scope:** Idempotence, DB locks beyond the single‑tx write, QR/payments, device‑trust, safe‑mode, etc.

---

## 2) Accounts & operation mapping (MVP)

* **Accounts:**

  * **1000** Cash/Top‑up Clearing (assets; **global**, `user_id` must be `NULL`)
  * **2000** Customer Credits (liabilities; **per user**, `user_id` **required**)
  * **4000** Sales Revenue (revenue; **global**)
  * **5000** Marketing Expense (expense; **global**)
* **Operations:**

  * **Top‑up X:** `Dr 1000 +X`, `Cr 2000(user) +X`
  * **Charge X:** `Dr 2000(user) +X`, `Cr 4000 +X` (reject if 2000(user) would go < 0)
  * **Bonus X:** `Dr 5000 +X`, `Cr 2000(user) +X`
  * **Reversal:** A new transaction with **exact mirror** entries of the origin (same accounts & amounts, opposite sides), linked via `reversal_of = origin_tx_id`. Max **1× reversal per origin**. **Reversal of a reversal is forbidden.**

---

## 3) Database schema (Drizzle + Postgres)

> **Note:** Provide full Drizzle migrations; the shapes below are the normative spec. Use **bigint** for all monetary amounts to prevent overflow.

### 3.1 Tables

**`ledger_transactions`**

* `id` UUID **PK**
* `created_at` `timestamptz` (UTC, default now)
* `type` `enum('topup'|'charge'|'bonus'|'reversal')`
* `origin_ref` `text` **nullable** (informational, not unique)
* `reversal_of` UUID **nullable** FK → `ledger_transactions.id`, with a **UNIQUE** constraint to enforce **max 1 reversal per origin**
* `created_by` UUID **nullable** (opaque; no FK to users)
* `context` `jsonb` (may include `{ note?: string, idempotency_key?: string }`) — store only; **no idempotency logic** here

**`ledger_entries`**

* `id` UUID **PK**
* `tx_id` UUID **FK** → `ledger_transactions.id` **ON DELETE CASCADE**
* `account_code` `int` (one of `1000|2000|4000|5000`)
* `user_id` UUID **nullable** (required when `account_code=2000`; must be `NULL` for `1000/4000/5000`)
* `side` `enum('debit'|'credit')`
* `amount_minor` **`bigint` > 0** (`CHECK (amount_minor > 0)`)

**Transaction invariants (enforced in app logic within a single DB tx):**

* Each transaction has **exactly 2 entries**: **1× debit + 1× credit**.
* For each `tx_id`: **Σdebit = Σcredit**.

**`account_balances`** (cache)

* `id` UUID **PK**
* `account_code` `int`
* `user_id` UUID **nullable**
* `balance_minor` **`bigint`** (for `2000` must **never** be < 0)
* `updated_at` `timestamptz` (UTC)

**account\_balances constraints/indexes**

* **CHECKs:**

  * If `account_code = 2000` → `user_id IS NOT NULL`.
  * If `account_code IN (1000, 4000, 5000)` → `user_id IS NULL`.
* **Partial uniques:**

  * `UNIQUE (account_code) WHERE user_id IS NULL` — one row per **global** account (1000/4000/5000).
  * `UNIQUE (account_code, user_id) WHERE user_id IS NOT NULL` — one row per **user** for account 2000.

**`trial_balance_daily`**

* `as_of_date` `date` **PK** (UTC date)
* `sum_debit` `bigint`
* `sum_credit` `bigint`
* `delta` `bigint` (must be 0 for ok)
* `status` `enum('ok'|'mismatch')`
* `details` `jsonb` (optional diagnostics)

### 3.2 Indexing (minimum)

* `ledger_entries (tx_id)`
* `ledger_entries (user_id, account_code, tx_id)`
* `ledger_transactions (created_at)`
* `account_balances (account_code)` + the two partial uniques above

---

## 4) API contracts (v1) — **all under `/api/v1/ledger`**

> Implement with existing auth middleware; do **not** modify auth. Responses are typed by **`/shared/contracts/ledger.ts`** and used by both BE and FE. All errors use the envelope `{ error, message, details? }`.

**4.1 Health**

* `GET /health` → `200 { ok: true, version: string, accounts: ["1000","2000","4000","5000"], featureFlags: { LEDGER_ENABLED: boolean, LEDGER_DEV_ENDPOINTS_ENABLED: boolean } }`

**4.2 Balances & transactions**

* `GET /balances/:userId` → `200 { userId: string, balanceMinor: number, updatedAt: string }`
* `GET /tx/:txId` → `200 { transaction, entries }` (returns full tx + its two entries)
* `GET /tx?userId=&limit=&cursor=` → cursor‑paginated feed for a user

  * `limit` ≤ 100, default 20
  * **Ordering:** `created_at DESC, id DESC`
  * **Cursor:** base64 of `"<created_at_iso>|<tx_id_uuid>"`

**4.3 Dev‑only operations** (return **403** when `LEDGER_DEV_ENDPOINTS_ENABLED=false`)

* `POST /dev/topup` — body: `{ userId: uuid, amountMinor: bigint>0, note?: string }` → `201 { txId }`
* `POST /dev/charge` — body: `{ userId: uuid, amountMinor: bigint>0, note?: string }` → `201 { txId }` (**reject** with 409 if 2000(user) would be < 0)
* `POST /dev/bonus` — body: `{ userId: uuid, amountMinor: bigint>0, reason: string }` → `201 { txId }`
* `POST /dev/reversal` — body: `{ txId: uuid }` → `201 { reversalTxId }`

**4.4 Trial balance**

* `POST /trial-balance/run` (admin only) → `200 { status: 'ok'|'mismatch', sumDebit: bigint, sumCredit: bigint, delta: bigint }`

**4.5 Error codes (HTTP mapping)**

* `INSUFFICIENT_FUNDS` → **409**
* `TX_NOT_FOUND` → **404**
* `REVERSAL_ALREADY_EXISTS` → **409**
* `REVERSAL_FORBIDDEN_TYPE` (e.g., reversal of a reversal) → **409**
* `VALIDATION_FAILED` → **422**
* `LEDGER_INVARIANT_BROKEN` → **500**
* `FORBIDDEN_DEV_ENDPOINT` (any `/dev/*` when disabled) → **403**

---

## 5) Transaction rules (one DB tx)

* Build the two `ledger_entries` first (exactly **one debit + one credit**), verify **Σdebit = Σcredit**.
* Apply `account_balances` updates in **the same DB transaction** using UPSERTs.

  * **Order:** update **2000(user)** first; **reject** if it would go below 0; then write global account(s).
* Commit; only **after commit** emit metrics/logs/notifications.
* **Reversal semantics:**

  * Only one reversal per origin (`UNIQUE (reversal_of)` in `ledger_transactions`).
  * Reversal over a `reversal` is **forbidden**.
  * Reversal **must exactly mirror** the origin’s entries (same accounts & amounts, opposite sides). Validate this.

---

## 6) Telemetry & audit (minimum)

* **Metrics (dev OK):**

  * `ledger_tx_total{type=topup|charge|bonus|reversal}`
  * `ledger_error_total{error=…}`
  * `ledger_trial_balance_status{status=ok|mismatch}`
* **Audit:** Store minimal context in `ledger_transactions.context` (no PII). Include `note`, `reason`, optional `idempotency_key`.

---

## 7) Frontend wiring (v1, dev‑only page)

* FE must **only** use `/shared/contracts/ledger.ts` types and call **`/api/v1/ledger/*`**. **No direct ad‑hoc JSON.**
* Add a small dev‑only page **“Ledger Health”** (visible when `LEDGER_ENABLED=true` **and** not prod):

  * Show **Health** info (`/health`) and feature flags.
  * Panel **User balance** (input `userId`, calls `/balances/:userId`).
  * Buttons to run **Top‑up / Charge / Bonus / Reversal** (these call `/dev/*`).
  * Button **Run Trial‑Balance** (POST `/trial-balance/run`).
* Create a thin typed FE wrapper client at **`/frontend/src/lib/api/ledgerClient.ts`** that imports **only** the shared contracts and hits `/api/v1/ledger/*` routes. **No UI logic** here.
* **Do not** modify existing auth or routes; reuse existing auth middleware for protected calls.

---

## 8) Validator & CI (E2E smoke)

* Add `scripts/validate-must1.ts` (TypeScript) performing this exact flow (fail = non‑zero exit):

  1. Ensure server is running (or start locally).
  2. Generate `testUserId` (UUID v4).
  3. `POST /api/v1/ledger/dev/topup {1000}` → expect **201**, then `GET /balances/:userId` → **balance=1000**.
  4. `POST /api/v1/ledger/dev/charge {400}` → **201**, balance **=600**.
  5. `POST /api/v1/ledger/dev/bonus {50}` → **201**, balance **=650**.
  6. `POST /api/v1/ledger/dev/reversal {txId:<charge_tx>}` → **201**, balance **=1000**.
  7. `POST /api/v1/ledger/trial-balance/run` → `status='ok'` and `delta=0`.
  8. Negative: `charge {2000}` → **409** `INSUFFICIENT_FUNDS`.
  9. Negative: second reversal of same tx → **409** `REVERSAL_ALREADY_EXISTS`.
  10. **Prod‑guard simulation:** set `LEDGER_DEV_ENDPOINTS_ENABLED=false` → any `/dev/*` returns **403** `FORBIDDEN_DEV_ENDPOINT`.
  11. **Optional parity check (if legacy wallet exists):** ověř, že **projekce** `wallets.balance_cents` (pokud je čtena přes existující BE službu) odpovídá `account_balances` pro `2000(user)` po krocích 3–6.
* Create npm script **`validate:must1`** → runs the validator and exits **0** only if all steps pass.
* In CI, run `validate:must1` on PRs targeting `main`.

---

## 9) Files & structure (expected locations)

* **`/shared/contracts/ledger.ts`** — Zod schemas & TS types for all requests/responses/enums/error codes.
* **`/backend/...`** — Routes mounted under `/api/v1/ledger/*`, service layer, DB models/migrations (Drizzle).
* **`/frontend/src/lib/api/ledgerClient.ts`** — Typed wrapper that imports from `/shared/contracts/ledger.ts` and calls the ledger API.
* **`/frontend/...`** — The small **Ledger Health** page (gated by `LEDGER_ENABLED` and non‑prod env).
* **`/scripts/validate-must1.ts`** — The E2E validator.

> **Integration guarantee:** The build must **fail** if FE or BE diverge from `contracts/ledger.ts`. FE wrapper and BE handlers **must import the same types**.

---

## 10) Checkpoints & commits (pause at each)

**A) Contracts & DB (stub)** — **CHECKPOINT A — STOP**

* Drizzle migrations (tables + indexes/constraints per §3).
* Shared types in `/shared/contracts/ledger.ts` (requests/responses, enums, error codes).
* Stub endpoints `/api/v1/ledger/*` with correct shapes (no logic).
* Typed FE client wrapper file created (no UI yet).
* NPM script `validate:must1` (temporary: just build + route map dump).
* **Commit:** `feat(ledger): contracts+db stub`.

**B) Backend implementation** — **CHECKPOINT B — STOP**

* Implement ledger service: entries writing, `account_balances` UPSERTs, reversal semantics, trial‑balance job.
* Map error codes exactly as in §4.5 with the unified error envelope.
* Metrics + audit context writes.
* Extend `validate:must1` to include **backend smoke** (see §8 steps up to 7).
* **Commit:** `feat(ledger): backend logic`.

**C) Frontend wiring (v1)** — **CHECKPOINT C — STOP**

* FE uses only `/shared/contracts/ledger.ts` + `/api/v1/ledger/*`.
* Add the **Ledger Health** dev page as in §7.
* Feature‑flag `LEDGER_ENABLED` (default OFF).
* **Do not** alter auth or non‑ledger endpoints.
* **Commit:** `feat(ledger): frontend wiring (dev page)`.

**D) Validator & CI** — **CHECKPOINT D — STOP**

* Implement full `scripts/validate-must1.ts` E2E (all 10 steps in §8).
* `npm run validate:must1` exits 0 only when all pass.
* CI job runs validator on PR → `main`.
* **Commit:** `chore(ledger): validator+ci`.

**E) Enable & dashboards**

* Enable `LEDGER_ENABLED` in dev/stage.
* Add basic metrics tiles: `trial_balance_status`, `ledger_tx_total{type}`.
* **Commit:** `ops(ledger): enable + dashboards`.

---

## 11) Security & access notes

* Dev endpoints `/dev/*` require **AdminAuthProvider** (admin role) i v ne‑prod; jinak 403.
* `user_id` is **opaque UUID** (no FK). Don’t join to `users`.
* No PII in logs/metrics; `context` is informational only.
* Pokud existuje `wallets.balance_cents`, je to **read‑model**; drž konzistenci **jednosměrným** streamem z ledgeru (viz Appendix A – dual‑write nebo asynchronní projekce).

---

## 12) Final acceptance (all must be true)

* `trial_balance/run` returns `status='ok'` and `delta=0` after the validator sequence.
* **Charge** never allows `2000(user)` to drop below 0.
* Exactly one **reversal** per origin; reversal of a reversal forbidden; reversal mirrors origin entries.
* `/dev/*` returns **403** when `LEDGER_DEV_ENDPOINTS_ENABLED=false` (and requires admin in non‑prod).
* The E2E validator passes all steps; CI green.
* FE builds and compiles **using shared contracts**, and the dev page works when `LEDGER_ENABLED=true`.

---

### If anything here conflicts with reality

* **STOP** and write a comment explaining:

  1. what conflicts,
  2. proposed minimal change,
  3. impact on FE/BE/DB,
  4. migration/compat plan.

> **Reminder:** Do **not** modify auth, legacy endpoints, or other modules. Keep everything under `/api/v1/ledger/*` and the shared contracts in `/shared/contracts/ledger.ts`. The purpose of this spec is to remove all ambiguity and guarantee FE↔BE fit via shared types + validator.

---

## Appendix A — Compatibility & Migration Plan (M0–M5)

> Cíl: zavést ledger jako **zdroj pravdy** bez rozbití legacy wallet toku. Postup je navržen tak, aby byl bezpečný a vratný.

**M0 – Pre‑flight**

* Zjisti, kde se dnes čte/zapisuje `wallets.balance_cents` a `transactions`.
* Zapni feature‑flagy jen v dev/stage: `LEDGER_ENABLED=true`, `LEDGER_DEV_ENDPOINTS_ENABLED=true`.

**M1 – Paralelní ledger schema**

* Vytvoř nové tabulky `ledger_transactions`, `ledger_entries`, `account_balances`, `trial_balance_daily` dle §3 (beze změny legacy tabulek).
* Nasad `GET /api/v1/ledger/health` a stuby endpointů (Checkpoint A).

**M2 – Dual‑write adaptér (dočasně)**

* Implementuj ledger operace (Checkpoint B) a **projekci**: po **commit** ledger transakce:

  * **Update** `account_balances` (součást téže DB tx).
  * **Po commitu** synchronizuj `wallets.balance_cents` pro daného uživatele (stejná hodnota jako `account_balances` u 2000). Pokud nemůžeš psát přímo, přidej malý **projekční job/worker**.
* Cílem je, aby legacy čtení dál fungovalo a zároveň byl ledger plně přesný.

**M3 – Backfill (pokud potřebuješ historii)**

* Pokud potřebuješ historická data z `transactions`, napiš jednorázový skript, který:

  * Z legacy `transactions` vyrobí **páry entries** v ledgeru se správným mapováním (topup/charge/bonus),
  * Zajistí Σdebit=Σcredit a aktualizuje `account_balances`.
  * K legacím ulož `origin_ref` (např. pů
