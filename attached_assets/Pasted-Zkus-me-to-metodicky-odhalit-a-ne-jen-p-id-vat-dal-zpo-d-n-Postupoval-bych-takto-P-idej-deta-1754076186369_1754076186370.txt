ZkusÃ­me to metodicky â€œodhalitâ€ a ne jen pÅ™idÃ¡vat dalÅ¡Ã­ zpoÅ¾dÄ›nÃ­. Postupoval bych takto:

PÅ™idej detailnÃ­ logovÃ¡nÃ­ v interceptoru

Do request.use i response.use vloÅ¾ console.log() s URL, stavem tokenu a flagem _retry.

ts
ZkopÃ­rovat
Upravit
axios.interceptors.response.use(
  res => res,
  async err => {
    const { config, response } = err;
    console.log('âœ–ï¸ Response error:', response?.status, config.url, 'retry?', config._retry);
    // â€¦
V if (status===401 && !config._retry) hned pÅ™ed refresh:

ts
ZkopÃ­rovat
Upravit
console.log('â†’ Starting token refresh, isRefreshing=', isRefreshing);
Po ÃºspÄ›Å¡nÃ©m refresh:

ts
ZkopÃ­rovat
Upravit
console.log('âœ… Refresh ok, new token=', data.accessToken, 'pendingRequests=', pendingRequests.length);
DÃ­ky tomu uvidÃ­Å¡ v konzoli, jestli se vÅ¯bec dostaneÅ¡ do refresh bloku a jak se Å™eÅ¡Ã­ fronta.

OvÄ›Å™, Å¾e getAccessToken/setAccessToken opravdu fungujÃ­

Zkus v debug konzoli (nebo krÃ¡tkÃ½m console.log) vypsat pÅ™ed a po volÃ¡nÃ­ setAccessToken hodnotu getAccessToken().

Ujisti se, Å¾e tokenStore nepouÅ¾Ã­vÃ¡ napÅ™Ã­klad localStorage bez synchronizace, nebo Å¾e hook, kterÃ½ token Äte, nenÃ­ zalogovÃ¡n v closure se starou hodnotou.

Zkontroluj, Å¾e /api/auth/refresh endpoint vracÃ­ platnÃ½ token okamÅ¾itÄ›

Vyvolej ho manuÃ¡lnÄ› (Postman/CURL) a ovÄ›Å™, Å¾e dostaneÅ¡ JSON { accessToken: â€œâ€¦â€ } a Å¾e tento token je pak v dalÅ¡Ã­m requestu skuteÄnÄ› pouÅ¾itÃ½.

OdstraÅˆ zpoÅ¾dÄ›nÃ­ a spolehej se na promise

MÃ­sto manuÃ¡lnÃ­ho await delay(150) dÅ¯vÄ›Å™uj tomu, Å¾e axios.post('/refresh') se vrÃ¡tÃ­ aÅ¾ bude token nastaven. ZbyteÄnÃ© delayy mohou zpÅ¯sobit nekonzistenci.

KlÃ­ÄovÃ© je, aby se novÃ½ token nastavil pÅ™ed tÃ­m, neÅ¾ se resolveujÃ­ post-refresh â€œpendingâ€ requesty:

ts
ZkopÃ­rovat
Upravit
const { data } = await axios.post('/api/auth/refresh', â€¦);
setAccessToken(data.accessToken);
pendingRequests.forEach(cb => cb(data.accessToken));
pendingRequests = [];
isRefreshing = false;
OvÄ›Å™ frontu pendingRequests

PÅ™idej logging i kdyÅ¾ do fronty pÅ™idÃ¡vÃ¡Å¡ novÃ© cb.

Pokud fronta zÅ¯stÃ¡vÃ¡ prÃ¡zdnÃ¡ nebo se do nÃ­ nepÅ™idÃ¡vÃ¡ vÃ­c neÅ¾ jeden callback, pak moÅ¾nÃ¡ nenÃ­ interceptor _retry flag sprÃ¡vnÄ› nastavenÃ½ nebo se config._retry nepÅ™enÃ¡Å¡Ã­.

Ujisti se, Å¾e vÅ¡echny axios instance sdÃ­lÃ­ stejnÃ½ interceptor

Pokud pouÅ¾Ã­vÃ¡Å¡ vÃ­c axios klientÅ¯ (jinÃ© baseURL, rÅ¯znÃ¡ nastavenÃ­), zkontroluj, Å¾e ten, co volÃ¡ /api/me/wallet i /api/me/history, mÃ¡ stejnÃ½ interceptor.

Simuluj race-condition

V konzoli nebo testu udÄ›lej rychlÃ½ back-to-back request:

js
ZkopÃ­rovat
Upravit
Promise.all([
  api.get('/api/me/wallet'),
  api.get('/api/me/history'),
]);
PodÃ­vej se, jak interceptor reaguje na oba najednou â€“ spustÃ­ se refresh dvakrÃ¡t, nebo jeden ÄekÃ¡, aÅ¾ ten druhÃ½ skonÄÃ­?

Nakonec â€“ debug proxy

Zapni proxy (ngrok/mitmproxy) pÅ™Ã­mo na localhost, sleduj HTTP hlaviÄky. Zkontroluj, Å¾e po â€retryâ€œ skuteÄnÄ› odchÃ¡zejÃ­ poÅ¾adavky s Authorization: Bearer <novÃ½-token>.

ğŸ¯ Jakmile uvidÃ­Å¡ v logu:

Å¾e pÅ™i 401 volÃ¡nÃ­ jdeÅ¡ do refresh bloku,

Å¾e setAccessToken mÄ›nÃ­ token,

a Å¾e pendingRequests se zavolajÃ­ s novÃ½m tokenem,

tak bys mÄ›l mÃ­t jistotu, Å¾e dalÅ¡Ã­ GETy uÅ¾ budou autorizovanÃ©. Pokud ne, chyba bude v tom, jak uklÃ¡dÃ¡Å¡/token pÅ™edÃ¡vÃ¡Å¡ mezi volÃ¡nÃ­mi, nebo v tom, Å¾e pouÅ¾Ã­vÃ¡Å¡ jinou axios instanci bez interceptoru.