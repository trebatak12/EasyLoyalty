ğŸ”© TechnickÃ½ nÃ¡vrh
mermaid
ZkopÃ­rovat
Upravit
sequenceDiagram
  participant C as Client (SPA | AdminUI | POS)
  participant API as REST/GraphQL Gateway
  participant Auth as Auth Service
  C->>API: POST /auth/login {email, pwd}
  API->>Auth: validateUser()
  Auth-->>API: {accessToken}+Set-Cookie(refresh_token)
  API-->>C: JSON{accessToken}
  Note over C: accessToken uloÅ¾en jen v RAM

  C-->>API: GET /orders (Authorization: Bearer \<access\>)
  API->>Auth: verifyJWT()
  Auth-->>API: userId/roles
  API-->>C: 200 OK
1. Backend (Node/Express)
ts
ZkopÃ­rovat
Upravit
// middleware/authenticate.ts
export const authenticate = async (req, res, next) => {
  const header = req.headers.authorization ?? "";
  const token  = header.split(" ")[1];
  if (!token) return res.sendStatus(401);

  try {
    req.user = jwt.verify(token, process.env.JWT_PUBLIC_KEY);
    next();
  } catch (err) {
    return res.sendStatus(401);
  }
};
ts
ZkopÃ­rovat
Upravit
// routes/auth.ts
router.post("/login", async (req, res) => {
  const { id, roles } = await validateUser(req.body);
  const accessToken  = signAccess({ id, roles });
  const refreshToken = await issueRefreshToken(id);

  res.cookie("refresh_token", refreshToken, {
    httpOnly: true,
    secure:   isProd,
    sameSite: "strict",
    path:     "/auth/refresh",
    maxAge:   30 * 24 * 60 * 60 * 1000,
  });
  res.json({ accessToken });
});

router.post("/refresh", async (req, res) => {
  const { refresh_token } = req.cookies;
  const payload = await verifyAndRotate(refresh_token); // throw if reused
  const accessToken  = signAccess({ id: payload.sub, roles: payload.roles });
  const newRefresh   = await issueRefreshToken(payload.sub);

  res.cookie("refresh_token", newRefresh, cookieOpts);
  res.json({ accessToken });
});
2. Front-end (React / POS UI)
ts
ZkopÃ­rovat
Upravit
// hooks/useAuth.ts
const login = async (cred) => {
  const { accessToken } = await api.post("/auth/login", cred);
  setAccess(accessToken);          // in-memory
};

const refresh = async () => {
  const { accessToken } = await api.post("/auth/refresh"); // cookie sent automatically
  setAccess(accessToken);
};

// axios interceptor â€“ auto-refresh on 401
axios.interceptors.response.use(undefined, async (err) => {
  if (err.response?.status === 401) {
    await refresh();
    err.config.headers.Authorization = `Bearer ${accessToken}`;
    return axios.request(err.config); // replay
  }
  throw err;
});
3. POS â€“ stejnÃ© flow
Electron/embedded Chrome â†’ cookie je automaticky uloÅ¾en; in-memory access token v Redux store.

âš™ï¸ Migrace krok-za-krokem
Backend umÃ­ oba systÃ©my paralelnÄ›
Accept: legacy header â†’ postupnÃ© vypÃ­nÃ¡nÃ­ starÃ½ch cest, nulovÃ© downtime.

Move refreshToken customers â†’ cookie
â€¢â€‰build novÃ½ /refresh endpoint
â€¢â€‰SPA release, kterÃ¡ pÅ™estane sahat do localStorage.

Deprecate session IDs (admins/POS)
Po 4 tÃ½dnech od pÅ™evedenÃ­ vÅ¡ech klientÅ¯ zahodÃ­Å¡ starÃ½ admin_sid/pos_session cookie.

ğŸ”’ BezpeÄnostnÃ­ detaily
Ochrana	Implementace
XSS	CSP (script-src 'self'), Trusted Types, React SSR escape.
CSRF	SameSite=Strict âŸ¹ 99 % pÅ™Ã­padÅ¯ vyÅ™eÅ¡eno. Pokud potÅ™ebujeÅ¡ 3rd-party iframe, pÅ™epneÅ¡ na Lax + X-CSRF-Token.
Token leak detection	refresh-token rotation + DB flag used; pokus o reuse â‡’ celÃ½ account force_logout.
Logout everywhere	Redis set blacklisted:access:<jti> s TTL = 15 min.
PCI / auditor log	Tabulka auth_log (event, ip, user-agent, userId).